// Prisma schema for Readloom
// This schema is designed for a book swapping platform with points-based exchanges

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - Core identity and authentication
// Designed for:
// - Secure authentication (password hashing handled in application layer)
// - Points-based book exchange system
// - Future OAuth support (email can be nullable for OAuth-only users)
// - Soft deletion support (deletedAt field for future implementation)
model User {
  id       String  @id @default(uuid()) // UUID for better security and distributed systems
  email    String  @unique // Unique email for authentication
  name     String? // Optional name (users might want to stay anonymous)
  password String // Hashed password (bcrypt) - required for credentials auth
  points   Int     @default(20) // Starting balance for book exchanges

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft deletion support - null means active user

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  // Book relationships
  ownedBooks    Book[]     @relation("BookOwner") // Books currently owned by this user
  wishlistItems Wishlist[] // Books in user's wishlist

  // Exchange relationships
  exchangesSent     Exchange[] @relation("ExchangeFromUser") // Exchanges where user is the owner
  exchangesReceived Exchange[] @relation("ExchangeToUser") // Exchanges where user is the requester

  // Report relationships
  reports Report[] // Reports created by this user

  // Forum relationships
  forumPosts ForumPost[] // Posts created by this user
  forumReplies ForumReply[] // Replies created by this user

  // Indexes for performance
  @@index([email])
  @@index([deletedAt]) // For filtering active users efficiently
  @@map("users")
}

// NextAuth required tables for session management
// These are required by NextAuth v5 with Prisma adapter
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Book Condition Enum
// Used to signal book quality and help with point valuation
enum BookCondition {
  POOR // Significant wear, may have missing pages
  FAIR // Noticeable wear but functional
  GOOD // Minor wear, well-maintained
  EXCELLENT // Like new, minimal wear
}

// Book Model - Single Digital Identity Per Physical Book
// 
// CRITICAL DESIGN PRINCIPLE:
// Each physical book has exactly ONE digital identity in the database.
// Ownership is TRANSFERRED, not copied, during exchanges.
// This ensures:
// - QR code history is preserved
// - No duplicate books can exist
// - Trust in the point system is maintained
//
// Ownership Rules:
// - A book MUST always have exactly one current owner (currentOwnerId is required)
// - Ownership is transferred, not duplicated, on exchange
// - Only the current owner can modify availability or approve exchanges
model Book {
  id String @id @default(uuid()) // UUID for unique identity

  // Basic Information
  title       String // Book title (required)
  author      String // Author name (required)
  description String? @db.Text // Optional description

  // Condition & Value Signals
  condition BookCondition @default(GOOD) // Physical condition of the book
  images    String[] // Array of image URLs (optional, but supported)
  location  String // City or region (required for discovery)
  
  // AI-Based Point Valuation
  // This field caches the AI-computed point value to avoid repeated API calls
  // Recalculated when: condition changes, wishlist count changes significantly, or rarity changes
  computedPoints Int? // AI-calculated point value (5-20 range), null means not yet calculated
  pointsLastCalculatedAt DateTime? // When points were last calculated (for cache invalidation)

  // Ownership & Availability
  // CRITICAL: currentOwnerId is required - a book MUST have an owner
  // This enforces single ownership and prevents orphaned books
  currentOwnerId String // Current owner (required, never null)
  currentOwner   User   @relation("BookOwner", fields: [currentOwnerId], references: [id], onDelete: Restrict)

  isAvailable Boolean  @default(true) // Whether book is available for exchange
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  wishlistItems  Wishlist[] // Users who have this book in their wishlist
  exchanges      Exchange[] // Exchanges involving this book
  historyEntries BookHistoryEntry[] // History entries for this book
  reports        Report[] // Reports about this book
  forumPosts     ForumPost[] // Forum discussions about this book

  // Indexes for performance
  @@index([currentOwnerId]) // Fast lookup of user's books
  @@index([isAvailable]) // Fast filtering of available books
  @@index([title]) // Fast search by title
  @@index([author]) // Fast search by author
  @@index([location]) // Fast filtering by location
  @@map("books")
}

// Wishlist Model
// 
// Purpose:
// - Allows users to signal interest in books
// - Wishlist count will be used as "demand signal" for AI-based point valuation
// - Supports discovery and matching algorithms
//
// Design:
// - Many-to-many relationship between User and Book
// - Unique constraint prevents duplicate wishlist entries
// - Soft deletion ready (can add deletedAt later if needed)
model Wishlist {
  id        String   @id @default(uuid())
  userId    String // User who added the book to wishlist
  bookId    String // Book in the wishlist
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Prevent duplicate wishlist entries
  @@unique([userId, bookId])
  @@index([userId]) // Fast lookup of user's wishlist
  @@index([bookId]) // Fast lookup of book's wishlist count
  @@map("wishlists")
}

// Exchange Status Enum
// Tracks the lifecycle of an exchange request
enum ExchangeStatus {
  REQUESTED // User has requested the book (points not deducted yet)
  APPROVED // Owner approved, points deducted, ownership transferred
  COMPLETED // Exchange is complete (final state)
  REJECTED // Owner rejected the request (no points affected)
  DISPUTED // Exchange is under dispute (points frozen)
}

// Exchange Model - Point-Based Book Exchange System
//
// CRITICAL DESIGN PRINCIPLES:
// 1. Single Active Exchange: A book can have only ONE active exchange at a time
//    This prevents conflicts and ensures clear ownership transfer
//
// 2. Points Deduction Timing: Points are deducted ONLY on approval, not on request
//    This prevents point farming and allows owners to reject without penalty
//
// 3. Ownership Transfer: Book ownership is TRANSFERRED, not duplicated
//    The book ID remains the same, only currentOwnerId changes
//
// 4. Atomic Operations: All critical updates (points, ownership) happen in transactions
//    This ensures data consistency and prevents race conditions
//
// Anti-Abuse Features:
// - Prevents repeat exchanges between same users (within time window)
// - Blocks circular exchange patterns (A → B → A)
// - Ensures only one active exchange per book
model Exchange {
  id String @id @default(uuid())

  // Book being exchanged
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Restrict)

  // Users involved
  fromUserId String // Current owner (who is giving the book)
  fromUser   User   @relation("ExchangeFromUser", fields: [fromUserId], references: [id], onDelete: Restrict)

  toUserId String // Requester (who wants the book)
  toUser   User   @relation("ExchangeToUser", fields: [toUserId], references: [id], onDelete: Restrict)

  // Exchange details
  pointsUsed Int // Points deducted from requester (equal to book value)
  status     ExchangeStatus @default(REQUESTED) // Current status of exchange

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime? // When exchange was completed

  // Relationships
  reports Report[] // Reports filed for this exchange

  // Indexes for performance and anti-abuse checks
  @@index([bookId]) // Fast lookup of exchanges for a book
  @@index([fromUserId]) // Fast lookup of exchanges sent by user
  @@index([toUserId]) // Fast lookup of exchanges received by user
  @@index([status]) // Fast filtering by status
  @@index([fromUserId, toUserId, createdAt]) // For detecting repeat exchanges
  @@map("exchanges")
}

// Report Reason Enum
// Predefined reasons for reporting issues with exchanged books
enum ReportReason {
  CONDITION_MISMATCH // Book condition doesn't match listing
  DAMAGED_BOOK // Book is damaged beyond expected condition
  WRONG_BOOK // Wrong book received (different edition/title)
  MISSING_PAGES // Pages are missing from the book
  FAKE_LISTING // Listing was misleading or fake
  OTHER // Other issues not covered above
}

// Report Status Enum
// Tracks the lifecycle of a report
enum ReportStatus {
  OPEN // Report submitted, awaiting review
  UNDER_REVIEW // Report is being reviewed by moderators
  RESOLVED // Report resolved (issue addressed)
  REJECTED // Report rejected (no issue found or invalid)
}

// Report Model - Issue Reporting System for Exchanged Books
//
// CRITICAL DESIGN PRINCIPLES:
// 1. Reports are linked to COMPLETED exchanges only
//    - Users can only report issues after receiving the book
//    - Prevents premature or invalid reports
//
// 2. Reports trigger exchange status change to DISPUTED
//    - Points are frozen (not auto-refunded)
//    - Ownership remains unchanged until resolution
//    - Prevents further actions on disputed exchanges
//
// 3. Anti-Abuse Safeguards:
//    - Rate limiting: Max reports per user per time window
//    - Duplicate prevention: Same exchange + reason cannot be reported twice
//    - Description length validation
//
// 4. Access Control:
//    - Only reporter and exchange participants can view reports
//    - Reports cannot be modified after submission
//    - Immutable audit trail for fairness
//
// 5. Fairness Preservation:
//    - Points frozen (not reverted) to prevent abuse
//    - Both parties can see the report
//    - Admin resolution required (can be mocked for hackathon)
model Report {
  id String @id @default(uuid())

  // Exchange and book being reported
  exchangeId String // Exchange this report is about
  exchange   Exchange @relation(fields: [exchangeId], references: [id], onDelete: Restrict)

  bookId String // Book involved in the exchange
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Restrict)

  // Reporter information
  reporterId String // User who created the report
  reporter   User   @relation(fields: [reporterId], references: [id], onDelete: Restrict)

  // Report details
  reason      ReportReason // Predefined reason for the report
  description String?      @db.Text // Optional detailed description
  status      ReportStatus @default(OPEN) // Current status of the report

  // Timestamps
  createdAt DateTime @default(now())

  // Indexes for performance and anti-abuse checks
  @@index([exchangeId]) // Fast lookup of reports for an exchange
  @@index([bookId]) // Fast lookup of reports for a book
  @@index([reporterId]) // Fast lookup of user's reports
  @@index([status]) // Fast filtering by status
  @@unique([exchangeId, reporterId, reason]) // Prevent duplicate reports (same exchange + user + reason)
  @@map("reports")
}

// Book History Entry Model - Immutable Book Journey
//
// CRITICAL DESIGN PRINCIPLES:
// 1. History is IMMUTABLE - entries are NEVER deleted
// 2. History belongs to the BOOK, not users
// 3. History survives user account deletion
//
// Why no userId reference:
// - If a user deletes their account, history should remain
// - History is about the book's journey, not user ownership
// - Prevents data loss and maintains book identity
//
// Why displayName snapshot:
// - Captures the name at time of entry
// - Provides context even if user account is deleted
// - Makes history more personal and readable
//
// Usage:
// - Each new owner can add ONE entry when they receive the book
// - Entries form a timeline showing the book's journey
// - Accessible via QR code: /book-history/{bookId}
model BookHistoryEntry {
  id String @id @default(uuid())

  // Book this entry belongs to
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // History details
  city            String // City where book was read
  readingDuration String? // How long the book was read (e.g., "2 weeks", "1 month")
  notes           String? @db.Text // Personal notes about reading experience
  displayName     String? // Snapshot of owner's name at time of entry (for display)

  // Timestamps
  createdAt DateTime @default(now())

  // Indexes for performance
  @@index([bookId]) // Fast lookup of all entries for a book
  @@index([createdAt]) // For chronological ordering
  @@map("book_history_entries")
}

// Forum Post Model - Book-Centric and General Community Discussions
//
// CRITICAL DESIGN PRINCIPLES:
// 1. Forum content survives user account deletion (userId is nullable)
// 2. Anonymous posting is supported (isAnonymous flag)
// 3. AI moderation flags abusive content (flagged field)
// 4. Posts can be tied to specific books OR general community discussions
//
// Why bookId is nullable:
// - Allows general community posts (not tied to a specific book)
// - Book-specific posts have bookId set
// - General posts have bookId = null
//
// Why userId is nullable:
// - If user deletes account, forum posts remain (community value)
// - Allows for future guest posting if needed
// - Backend still tracks userId for moderation even if anonymous
//
// Why isAnonymous flag:
// - Encourages honest discussions without fear
// - Users can choose privacy when sharing sensitive opinions
// - Frontend hides username when isAnonymous = true
//
// Why flagged field:
// - AI moderation marks abusive content
// - Flagged posts are hidden from public view
// - Allows manual review in future
model ForumPost {
  id String @id @default(uuid())

  // Book this post is about (nullable for general community posts)
  bookId String?
  book   Book?  @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // User who created the post (nullable for content persistence)
  // Even if anonymous, we store userId for moderation tracking
  userId String?
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Post content
  content String @db.Text // The actual discussion content

  // Anonymity and moderation
  isAnonymous Boolean @default(false) // If true, hide username on frontend
  flagged     Boolean @default(false) // AI moderation flag (hide if true)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  replies ForumReply[] // Replies to this post

  // Indexes for performance
  @@index([bookId]) // Fast lookup of posts for a book (null for general posts)
  @@index([userId]) // Fast lookup of user's posts (for moderation)
  @@index([flagged]) // Fast filtering of flagged posts
  @@index([createdAt]) // For chronological ordering
  @@map("forum_posts")
}

// Forum Reply Model - Replies to Forum Posts
//
// DESIGN PRINCIPLES:
// - Same anonymity and moderation features as ForumPost
// - Replies are tied to specific posts
// - Content persists even if user account is deleted
model ForumReply {
  id String @id @default(uuid())

  // Post this reply belongs to
  postId String
  post   ForumPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  // User who created the reply (nullable for content persistence)
  userId String?
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Reply content
  content String @db.Text // The reply content

  // Anonymity and moderation
  isAnonymous Boolean @default(false) // If true, hide username on frontend
  flagged     Boolean @default(false) // AI moderation flag (hide if true)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for performance
  @@index([postId]) // Fast lookup of replies for a post
  @@index([userId]) // Fast lookup of user's replies (for moderation)
  @@index([flagged]) // Fast filtering of flagged replies
  @@index([createdAt]) // For chronological ordering
  @@map("forum_replies")
}
